Fibonacci h√©t v√°ltozatban

A Fibonacci-sz√°mok j√≥l ismert matematikai defin√≠ci√≥ja:
ùêπ0 = 0 ùêπ1 = 1 ùêπùëñ = ùêπùëñ‚àí2 + ùêπùëñ‚àí1, ha ùëñ > 1

Na√≠v rekurz√≠v megold√°sunk ezt k√∂veti.
Az ùëñ-edik Fibonacci-sz√°m meghat√°roz√°sa el√°gaz√≥ rekurzi√≥val nagyon rossz hat√©konys√°g√∫, mert a k√©t el√°gaz√≥ √°gat
minden egyes rekurz√≠v l√©p√©sben √∫jra meg √∫jra teljesen be kell j√°rni, azaz az ùëñ-edikn√©l kisebb Fibonacci-sz√°mokat √∫jra
√©s √∫jra ki kell sz√°molni, r√°ad√°sul a r√©szeredm√©nyeket az egyre m√©ly√ºl≈ë veremben kell t√°rolni.
Fib.fib(5) kisz√°m√≠t√°s√°nak folyamata:

defmodule Fib do
    # Tree recursion
    # O(2^n) fut√°si id≈ë, O(2^n) t√°rhely
    @spec fib(i :: integer()) :: n :: integer()
    # n az i-edik Fibonacci-sz√°m
    def fib(0), do: 0
    def fib(1), do: 1
    def fib(i), do: fib(i-1) + fib(i-2)
end

Fib.fib(23) #|> IO.inspect()
28657

defmodule FibM do
    # Memoization (top down) ‚Äì dinamikus programoz√°s
    # O(n) fut√°si id≈ë, O(n) t√°rhely
    @spec fib_mem(i :: integer()) :: n :: integer()
    # n az i-edik Fibonacci-sz√°m
    def fib_mem(i), do: fib_m(i, %{0 => 0, 1 => 1}) |> elem(0)
    @type mem() :: %{index :: integer() => value :: integer()}
    @spec fib_m(i :: integer(), mem :: mem()) :: {n :: integer(), uj_mem :: mem()}
    # n az i-edik Fibonacci-sz√°m
    def fib_m(i, mem) do
        case mem[i] do # case nem v√°lthat√≥ ki mintailleszt√©ssel
            nil ->
            {prev, memp} = fib_m(i-2, mem)
            {curr, memc} = fib_m(i-1, memp)
            val = prev + curr
            {val, Map.put(memc, i, prev+curr)}

            val ->
            {val, mem}
        end
    end
end

FibM.fib_mem(63) #|> IO.inspect()
6557470319842

defmodule FibT do
    # Tabulation (bottom-up) ‚Äì dinamikus programoz√°s
    # O(n) fut√°si id≈ë, O(n) t√°rhely
    @spec fib_tab(i :: integer()) :: n :: integer()
    # n az i-edik Fibonacci-sz√°m
    def fib_tab(i), do: fib_t(i, 2, %{0 => 0, 1 => 1})

    @type tab() :: %{index :: integer() => value :: integer()}

    @spec fib_t(i :: integer(), j :: integer(), tab :: tab()) :: n :: integer()
    # n az i-edik Fibonacci-sz√°m
    def fib_t(i, j, tab) when i < j, do: tab[i]
    def fib_t(i, j, tab) do
        tab0 = Map.put(tab, j, tab[j-2] + tab[j-1])
        fib_t(i, j+1, tab0)
    end
end

FibT.fib_tab(63) #|> IO.inspect()
6557470319842

defmodule FibAerl do
    # Tabulation (bottom-up) ‚Äì dinamikus programoz√°s
    # O(n) fut√°si id≈ë, O(n) t√°rhely
    # Erlang :array
    @spec fib_tab(i :: integer()) :: n :: integer()
    # n az i-edik Fibonacci-sz√°m
    def fib_tab(i), do: fib_t(i, 2, :array.set(1,1,(:array.set(0,0,:array.new()))))

    @type tab(integer) :: :array.arrayinteger(integer)

    @spec fib_t(i :: integer(), j :: integer(), tab :: tab(integer())) :: n :: integer()
    # n az i-edik Fibonacci-sz√°m
    def fib_t(i, j, tab) when i < j, do: :array.get(i, tab)
    def fib_t(i, j, tab) do
        prev = :array.get(j-2, tab)
        curr = :array.get(j-1, tab)
        tab0 = :array.set(j, prev+curr, tab)
        fib_t(i, j+1, tab0)
    end
end

FibAerl.fib_tab(1023) #|> IO.inspect()
2785293550699592923938812412668093509353307352123703806913182668987369503203465183625616759613324452749958549669966882191defmodule X do
2

@type array(int) :: :array.array(int)
{:module, X, <<70, 79, 82, 49, 0, 0, 5, ...>>, :ok}

defmodule FibAex do
    # Tabulation (bottom-up) ‚Äì dinamikus programoz√°s
    # O(n) fut√°si id≈ë, O(n) t√°rhely
    # Elixir Array
    @spec fib_tab(i :: integer()) :: n :: integer()
    # n az i-edik Fibonacci-sz√°m
    def fib_tab(i), do: fib_t(i, 2, Arrays.new([0,1]))

    @type tab(integer) :: :array.arrayinteger(integer)

    @spec fib_t(i :: integer(), j :: integer(), tab :: tab(integer)) :: n :: integer()
    # n az i-edik Fibonacci-sz√°m
    def fib_t(i, j, tab) when i < j, do: Arrays.get(tab, i)
    def fib_t(i, j, tab) do
        prev = Arrays.get(tab, j-2)
        curr = Arrays.get(tab, j-1)
        tab0 = Arrays.append(tab, prev+curr)
        fib_t(i, j+1, tab0)
    end
end

FibAex.fib_tab(1023) #|> IO.inspect()
2785293550699592923938812412668093509353307352123703806913182668987369503203465183625616759613324452749958549669966882191defmodule FibLtab do

defmodule FibLtab do
    # Tabulation (bottom-up) ‚Äì dinamikus programoz√°s
    # O(n) fut√°si id≈ë, O(n) t√°rhely
    # Elixir List
    @spec fib_tab(i :: integer()) :: n :: integer()
    # n az i-edik Fibonacci-sz√°m
    def fib_tab(i), do: fib_t(i, 2, [1,0])

    @type tab(integer) :: :array.arrayinteger(integer)

    @spec fib_t(i :: integer(), j :: integer(), tab :: tab(integer)) :: n :: integer()
    # n az i-edik Fibonacci-sz√°m
    def fib_t(i, j, tab) when i < j, do: hd(tab)
    def fib_t(i, j, tab) do
        prev = hd(tl(tab))
        curr = hd(tab)
        tab0 = [prev+curr | tab]
        fib_t(i, j+1, tab0)
    end
end

FibLtab.fib_tab(63) #|> IO.inspect()
6557470319842

defmodule FibI do
    # Space optimized (bottom up)
    # O(n) fut√°si id≈ë, O(1) t√°rhely
    @spec fib_iter(i :: integer()) :: n :: integer()
    # n az i-edik Fibonacci-sz√°m
    def fib_iter(i), do: fib_i(i, 1, 0)
    @spec fib_i(i :: integer(), curr :: integer(), prev :: integer())
    :: n :: integer()
    # n az i-edik Fibonacci-sz√°m
    defp fib_i(0, _curr, prev), do: prev
    defp fib_i(1, curr, _prev), do: curr
    defp fib_i(i, curr, prev), do: fib_i(i-1, prev+curr, curr)
end

FibI.fib_iter(2203) #|> IO.inspect()
1122758802217805139807062374577053774698103216103328357864188914950437190254759573354894973127917403652055351021118529152Benchee.run(

# M√≥dos√≠tott v√°ltozat a memoiz√°l√°si l√©p√©sek k√∂vet√©s√©re
defmodule FibMm do
    @spec fib_mem(i :: integer()) :: mem :: %{integer() => integer()}
    def fib_mem(i), do: FibM.fib_m(i, %{0 => 0, 1 => 1}) |> elem(1)
end

FibMm.fib_mem(5)
%{0 => 0, 1 => 1, 2 => 1, 3 => 2, 4 => 3, 5 => 5}

# Interakt√≠v bemenet (n slider); √∂n√°ll√≥ cell√°ba kell rakni
cell = Kino.Input.number("Fibonacci index", default: 10, min: 0, max: 35)
# Bemenet beolvas√°sa
index =
cell
|> IO.inspect(label: "Kino input cell")
|> Kino.Input.read()
|> IO.inspect(label: "Kino input read")
Kino input cell: %Kino.Input{
ref: "p476tnlhyud6wikh4h7dsiw4yzqqrhot",
id: "131674189",
destination: {Kino.SubscriptionManager,
:"livebook_x5hje53k--xgga5nyt@127.0.0.1"},
attrs: %{
default: 10,
label: "Fibonacci index",
type: :number,
debounce: :blur
}
}

Kino input read: 10
10

# T√°bl√°zat
mem = FibMm.fib_mem(index)
Explorer.DataFrame.new(Enum.map(mem, fn {k, v} -> %{index: k, value: inspect(%{k => v})} end))
#Explorer.DataFrame<
Polars[11 x 2]
index s64 [0, 1, 2, 3, 4, ...]
value string ["%{0 => 0}", "%{1 => 1}", "%{2 => 1}", "%{3 => 2}", "%{4 => 3}", ...]


defmodule FibTdbg do
    # Tabulation (bottom-up) ‚Äì dinamikus programoz√°s
    # O(n) fut√°si id≈ë, O(n) t√°rhely
    @spec fib_tab(i :: integer()) :: n :: integer()
    # n az i-edik Fibonacci-sz√°m
    def fib_tab(i), do: fib_t(%{0 => 0, 1 => 1}, 2, i)

    @type fib() :: %{index :: integer() => value :: integer()}

    @spec fib_t(mem :: fib(), j :: integer(), i :: integer()) :: n :: integer()
    # n az i-edik Fibonacci-sz√°m
    def fib_t(tab, j, i) when j > i, do: tab[i]
    def fib_t(tab, j, i) do
        tab
        |> Map.put(j, tab[j-1] + tab[j-2])
        |> fib_t(j+1, i)
        |> dbg()
    end
end

FibTdbg.fib_tab(8) #|> IO.inspect()
21
6