A számtekercs feladvány

Adott egy n*n mezőből álló, négyzet alakú tábla, amelynek egyes mezőiben 1 és m közötti számok vannak. A feladat az, hogy további 1 és m közötti számokat helyezzünk el a táblában úgy, hogy az alábbi feltételek teljesüljenek:
Minden sorban és minden oszlopban az 1..m számok mindegyike pontosan egyszer szerepel.
A bal felső sarokból induló tekeredő vonal mentén a számok rendre az 1,2,...m,1,2,...,m,... sorrendben követik egymást.
A tekeredő vonalat a következőképpen definiáljuk. Először a négyzet első sorában haladunk balról jobbra, majd az utolsó oszlopban felülről lefelé. Ezután az utolsó sorban megyünk jobbról balra, majd az első oszlopban alulról fölfelé, egészen a 2. sor 1. mezőjéig. Miután így bejártuk a négyzetes tábla szélső sorait és oszlopait, rekurzívan folytatjuk a bejárást a 2. sor 2. mezőjében kezdődő (n-2)*(n-2) mezőből álló négyzettel.

Az 1. ábra egy feladványt ábrázol, a 2. ábra ennek (egyetlen) megoldását mutatja.

-----------------------\
                  2     |
/-------------------\   |
|     1             |   |
|   /-----------\   |   |
|   |           |   |   |
|   |   /---\   |   |   |
|   |   |       |   | 1 |
|   |   \-------/   |   |
|   |               |   |
|   \---------------/   |
|                       |
\-----------------------/

1. ábra. Egy feladvány (n=6, m=3)	

           	
-----------------------\
  1   -   -   -   2   3 |
/-------------------\   |
| -   1   2   3   - | - |
|   /-----------\   |   |
| - | 3   1   2 | - | - |
|   |   /---\   |   |   |
| - | 2 | 3   - | - | 1 |
|   |   \-------/   |   |
| 3 | -   -   -   1 | 2 |
|   \---------------/   |
| 2   -   -   1   3   - |
\-----------------------/

2. ábra. A feladvány megoldása

A feladat egy Elixir-függvény megírása.
A függvény paramétere egy szöveges feladványleíró-lista, az eredménye pedig a kiterített számtekercs, azaz egy olyan lista, amely a bal felső mezőtől kezdve a tekeredő vonal sorrendjében tartalmazza a koordináta–érték párokat.

A szöveges feladványleíró-lista egy sztringekből álló, legalább kételemű lista, melynek első eleme a tábla méretét (n), második eleme a ciklus hosszát (m), esetleges további elemei pedig a kitöltött mezők koordinátáját (row, col) és értékét (val) adják meg. Feltételezheti, hogy a sztringekben csak egész számok vannak, n és m mindig meg van adva, továbbá ha vannak kitöltött mezők, akkor a row, col, val hármasok elemei mindig meg vannak adva. A sztringekben az egész számok között legalább egy szóköz van, előttük vagy utánuk 0 vagy több szóköz lehet. Például az 1. ábrán látható feladványt így írjuk le:

   ["6", "3", "1 5 2", "2 2 1", "4 6 1"]

A függvény eredménye ebben az esetben ez lesz:
  [{{1, 1}, nil}, {{1, 2}, nil}, {{1, 3}, nil}, {{1, 4}, nil}, {{1, 5},   2}, {{1, 6}, nil},
   {{2, 6}, nil}, {{3, 6}, nil}, {{4, 6},   1}, {{5, 6}, nil}, {{6, 6}, nil},
   {{6, 5}, nil}, {{6, 4}, nil}, {{6, 3}, nil}, {{6, 2}, nil}, {{6, 1}, nil},
   {{5, 1}, nil}, {{4, 1}, nil}, {{3, 1}, nil}, {{2, 1}, nil},
   {{2, 2},   1}, {{2, 3}, nil}, {{2, 4}, nil}, {{2, 5}, nil},
   {{3, 5}, nil}, {{4, 5}, nil}, {{5, 5}, nil},
   {{5, 4}, nil}, {{5, 3}, nil}, {{5, 2}, nil},
   {{4, 2}, nil}, {{3, 2}, nil},
   {{3, 3}, nil}, {{3, 4}, nil},
   {{4, 4}, nil}, {{4, 3}, nil}]

Elixir-specifikációk

Típusok a feladvány alapadatainak megadására
    @type size()  :: integer() # tábla mérete (0 < n)
    @type cycle() :: integer() # ciklus hossza (0 < m <= n)
    @type value() :: integer() # mező értéke (0 < v <= m)

Típusok egy mező koordinátáinak megadására
    @type row()   :: integer()       # sor száma (1-től n-ig)
    @type col()   :: integer()       # oszlop száma (1-től n-ig)
    @type field() :: {row(), col()}  # mező koordinátái

Típusok a feladvány leírására
    @type field_value()     :: {field(), value()}       # mező és értéke
    @type field_opt_value() :: {field(), value() | nil} # mező és opcionális értéke

A szöveges feladványleíró-lista típusa
    @type list_desc() :: [String.t()] # 1. elem: méret, 2. elem: ciklushossz, többi elem esetleg: mezők és értékük 

A helix/1 függvény specifikációja
    @spec helix(ps::list_desc()) :: gs::[field_opt_value()]
    # A ps szöveges feladványleíró-lista szerinti számtekercs kiterített listája gs

Példák
    iex> Khf2.helix([" 2", "1 ", " 2   2 1 "])
    [{{1, 1}, nil}, {{1, 2}, nil}, {{2, 2}, 1}, {{2, 1}, nil}]
    
    iex> Khf2.helix(["  3  ", "  2  "])
    [{{1, 1}, nil}, {{1, 2}, nil}, {{1, 3}, nil}, {{2, 3}, nil}, {{3, 3}, nil}, {{3, 2}, nil}, {{3, 1}, nil}, {{2, 1}, nil}, {{2, 2}, nil}]
    
    iex> Khf2.helix(["3 ", " 2", "1 1 1", "1 3 2", "2 2 1", "3 1 2", "  3  3  1  "])
    [{{1, 1}, 1}, {{1, 2}, nil}, {{1, 3}, 2}, {{2, 3}, nil}, {{3, 3}, 1}, {{3, 2}, nil}, {{3, 1}, 2}, {{2, 1}, nil}, {{2, 2}, 1}]
    
    iex> Khf2.helix(["3", "2", "3 3 1", "1 3 2", "3 1 2", "2 2 1"])
    [{{1, 1}, nil}, {{1, 2}, nil}, {{1, 3}, 2}, {{2, 3}, nil}, {{3, 3}, 1}, {{3, 2}, nil}, {{3, 1}, 2}, {{2, 1}, nil}, {{2, 2}, 1}]
    
    iex> Khf2.helix(["   4", "   2", "  1 3 1", "  2 3 2"])
    [{{1, 1}, nil}, {{1, 2}, nil}, {{1, 3},   1}, {{1, 4}, nil},
     {{2, 4}, nil}, {{3, 4}, nil}, {{4, 4}, nil},
     {{4, 3}, nil}, {{4, 2}, nil}, {{4, 1}, nil},
     {{3, 1}, nil}, {{2, 1}, nil},
     {{2, 2}, nil}, {{2, 3},   2},
     {{3, 3}, nil}, {{3, 2}, nil}]
    
Egyéb követelmények

A modul neve Khf2 legyen, a segédfüggvények legyenek lokálisak (defp), írjon hozzájuk típusspecifikációt és fejkommentként tömör leírást is. A beadott programokat Linux környezetben Elixir 1.18 (Erlang/OTP 28) rendszerrel teszteljük.

Segítség

Sablon a program megírásához: 

defmodule Khf2 do

  @moduledoc """
  Számtekercs kiterítése
  @author "Egyetemi Hallgató <egy.hallg@edu.bme.hu>"
  @date   "2025-10-xx"
  """

  # Alapadatok
  @type size()  :: integer() # tábla mérete (0 < n)
  @type cycle() :: integer() # ciklus hossza (0 < m <= n)
  @type value() :: integer() # mező értéke (0 < v <= m vagy "")

  # Mezőkoordináták
  @type row()   :: integer()       # sor száma (1-től n-ig)
  @type col()   :: integer()       # oszlop száma (1-től n-ig)
  @type field() :: {row(), col()}  # mező koordinátái

  # Feladványleírók
  @type field_value() :: {field(), value()}           # mező és értéke
  @type field_opt_value() :: {field(), value() | nil} # mező és opcionális értéke

  @type list_desc() :: [String.t()] # 1. elem: méret, 2. elem: ciklushossz,
                                    # többi elem esetleg: mezők és értékük

  @spec helix(ps::list_desc()) :: gs::[field_opt_value()]
  # A ps szöveges feladványleíró-lista szerinti számtekercs kiterített listája gs
  def helix(ps) do ...
  end

end


Szkript a tesztesetek futtatásához:

defmodule Khf2Testcases do

  testcases = # [{ps, pd}]
    [
      {
        [" 6", "3 ", " 1   5   2  ", "2 2 1", "4 6 1"],

        [
          {{1, 1}, nil}, {{1, 2}, nil}, {{1, 3}, nil}, {{1, 4}, nil}, {{1, 5}, 2},
          {{1, 6}, nil}, {{2, 6}, nil}, {{3, 6}, nil}, {{4, 6}, 1}, {{5, 6}, nil},
          {{6, 6}, nil}, {{6, 5}, nil}, {{6, 4}, nil}, {{6, 3}, nil}, {{6, 2}, nil},
          {{6, 1}, nil}, {{5, 1}, nil}, {{4, 1}, nil}, {{3, 1}, nil}, {{2, 1}, nil},
          {{2, 2}, 1}, {{2, 3}, nil}, {{2, 4}, nil}, {{2, 5}, nil}, {{3, 5}, nil},
          {{4, 5}, nil}, {{5, 5}, nil}, {{5, 4}, nil}, {{5, 3}, nil}, {{5, 2}, nil},
          {{4, 2}, nil}, {{3, 2}, nil}, {{3, 3}, nil}, {{3, 4}, nil}, {{4, 4}, nil},
          {{4, 3}, nil}
        ]
      },


      {
        ["  6", "6", "1 5 2", "2 2 1", "  4 6  1 "],

        [
          {{1, 1}, nil}, {{1, 2}, nil}, {{1, 3}, nil}, {{1, 4}, nil}, {{1, 5}, 2},
          {{1, 6}, nil}, {{2, 6}, nil}, {{3, 6}, nil}, {{4, 6}, 1}, {{5, 6}, nil},
          {{6, 6}, nil}, {{6, 5}, nil}, {{6, 4}, nil}, {{6, 3}, nil}, {{6, 2}, nil},
          {{6, 1}, nil}, {{5, 1}, nil}, {{4, 1}, nil}, {{3, 1}, nil}, {{2, 1}, nil},
          {{2, 2}, 1}, {{2, 3}, nil}, {{2, 4}, nil}, {{2, 5}, nil}, {{3, 5}, nil},
          {{4, 5}, nil}, {{5, 5}, nil}, {{5, 4}, nil}, {{5, 3}, nil}, {{5, 2}, nil},
          {{4, 2}, nil}, {{3, 2}, nil}, {{3, 3}, nil}, {{3, 4}, nil}, {{4, 4}, nil},
          {{4, 3}, nil}
        ]
      },


      {
        ["3", "2", "1 3 2"],

        [
          {{1, 1}, nil}, {{1, 2}, nil}, {{1, 3}, 2}, {{2, 3}, nil}, {{3, 3}, nil},
          {{3, 2}, nil}, {{3, 1}, nil}, {{2, 1}, nil}, {{2, 2}, nil}
        ]
      },


      {
        ["3", "2"],

        [
          {{1, 1}, nil}, {{1, 2}, nil}, {{1, 3}, nil}, {{2, 3}, nil}, {{3, 3}, nil},
          {{3, 2}, nil}, {{3, 1}, nil}, {{2, 1}, nil}, {{2, 2}, nil}
        ]
      },


      {
        ["   4", "   2", "  1 3 1", "  2 3 2"],

        [
          {{1, 1}, nil}, {{1, 2}, nil}, {{1, 3}, 1}, {{1, 4}, nil}, {{2, 4}, nil},
          {{3, 4}, nil}, {{4, 4}, nil}, {{4, 3}, nil}, {{4, 2}, nil}, {{4, 1}, nil},
          {{3, 1}, nil}, {{2, 1}, nil}, {{2, 2}, nil}, {{2, 3}, 2}, {{3, 3}, nil},
          {{3, 2}, nil}
        ]
      },


      {
        [" 2", "1 ", " 2   2 1 "],

        [{{1, 1}, nil}, {{1, 2}, nil}, {{2, 2}, 1}, {{2, 1}, nil}]
      },


      {
        ["3 ", " 2", "1 1 1", "1 3 2", "2 2 1", "3 1 2", "  3   3   1  "],

        [
          {{1, 1}, 1}, {{1, 2}, nil}, {{1, 3}, 2}, {{2, 3}, nil}, {{3, 3}, 1},
          {{3, 2}, nil}, {{3, 1}, 2}, {{2, 1}, nil}, {{2, 2}, 1}
        ]
      },


      {
        ["3", "2", "3 3 1", "1 3 2", "3 1 2", "2 2 1"],

        [
          {{1, 1}, nil}, {{1, 2}, nil}, {{1, 3}, 2}, {{2, 3}, nil}, {{3, 3}, 1},
          {{3, 2}, nil}, {{3, 1}, 2}, {{2, 1}, nil}, {{2, 2}, 1}
        ]
      }

     ]


  for {i, {ps, pd}} <- Enum.zip(1..length(testcases), testcases) do
      {"Test case #{i}", (Khf2.helix(ps) === pd)} |> IO.inspect
  end

end